<!DOCTYPE html>
<html lang="en">
<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Khan's Scripts</title>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Fragment+Mono:ital@0;1&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="../style.css">
      <link rel="stylesheet" href="commonPython.css">
      <link rel="stylesheet" href="../common/common.css">
      <link rel="stylesheet" href="../prism.css">
      <script src="../prism.js"></script>
</head>
<body>
      <main>
            <h1>Decorators</h1>
            <p>In Python, decorators are a design pattern that allows you to modify or extend the behavior of functions or methods without altering their original code. They are typically used to add functionality to an existing function in a clean, readable, and reusable way.</p>

            <h2>Hoe decorators work?</h2>
            <p>A decorator is a function that takes another function as input and returns a new function that adds some behavior to the original one. The @decorator_name syntax is used to apply a decorator to a function. Here's the basic structure of a decorator:</p> 
            <h2>Syntax:</h2>
            <pre class="lang-python"><code>def decorator(func):
    def wrapper():
        # Code before the function call
        func()  # Call the original function
        # Code after the function call
    return wrapper
            </code></pre>
            <h2>Explanation:</h2>
                  <ul>
                        <li><span>func:</span>The function being decorated.</li>
                        <li><span>wrapper:</span>
                            A new function that adds extra functionality before and/or after the original function is executed.</li>
                  </ul>

                  <h2>Applying a decorator:</h2>
                  <p>You can apply a decorator to a function by placing the @decorator_name directly above the function definition:</p>
                  <h2>Syntax:</h2>
                  <pre class="lang-python"><code>@decorator
def my_function():
    print("This is my function.")
my_function()
                </code></pre>
                <p>When my_function() is called, the decorator modifies its behavior by adding code before or after the original function's execution.</p>
                <h2>Example:</h2>
                <pre class="lang-python"><code>
def greet_decorator(func):
    def wrapper():
        print("Hello!")
        func()
        print("Goodbye!")
    return wrapper

@greet_decorator
def say_hello():
    print("How are you?")

say_hello()
</code></pre>
            <h2>Output:</h2>
            <pre class="lang-python"></pre><code>Hello!
How are you?
Goodbye!
            </code></pre>
            <p>In this example, the greet_decorator adds the "Hello!" and "Goodbye!" messages around the say_hello() function.</p>
            <h2>Decorators with arguments:</h2>
            <h2>Conclusion</h2>
            File handling in Python allows for efficient reading, writing, and appending to files using the open() function with different modes. The with statement ensures files are safely closed after operations, and exception handling prevents errors. This makes Python's file handling both simple and robust for managing data.

      </main>
      <script src="../common/common.js"></script>
      <script src="commonPython.js"></script>
</body>
</html>